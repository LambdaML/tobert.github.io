---
id: "2011-07-21-new-experiment-language-choices"
title: "New Experiment Language Choices"
pubdate: "2011-09-21T06:13:25-07:00"
abstract: Language choices
tags: [bespoke, golang, git, programming, perl, configuration management]
---
<div class="css-full-post-content js-full-post-content">
  (edit: I'm still tinkering with the ideas and have started learning Go, but will probably end up doing this project
  in either python or bash)<br />
  <br />
  My evolving side project is a configuration management suite that:
  <pre>
1.) uses as much of git as possible and sensible<br />2.) lightweight<br />3.) simple things must be very fast turnaround to/from thought&lt;-&gt;production<br />4.) all configs (and binaries if you like) versioned bit-for-bit for all time
</pre><br />
  <br />
  I'll write more about the overall system design later; I've written a bit of an intro and will post it when I have
  code to present (here's what I have in mind for fs permissions: <a href="https://gist.github.com/1096381">gist</a>)
  I'm implementing some tools now that I've got the branching &amp; config strategy worked out. I could whip out a lot
  of it in Perl pretty handily, but I suspect it'll be a one-man show forever if I go that route. At work, almost
  everything is done in Ruby, which I still don't really like much. Plus two of the leading CFM tools are already in
  Ruby, so I feel like it's time for something different. So, here's what I'm considering and why:
  <pre>
1) Go<br />  +) generates regular binaries, no VM to maintain on nodes<br />  +) good C compatibility, already has libgit2 bindings<br />  +) garbage collected, first-class strings<br />  +) (yes, +) DNA from C, Erlang, Plan9, and Inferno/Limbo<br />     e.g.) lightweight processes, channels, goroutines<br />  -) I'd have to learn from scratch<br />  -) AFAIK nobody on my team knows/uses it (obscure)<br />2) C<br />  +) compiled, works literally everywhere, knows your mom intimately<br />  +) good match with git, openssl/gnutls, and libgit2<br />  +) igraph looks neat for smart path &amp; network<br />  -) manual memory, thread, and process management :(<br />  -) I'm rusty as the Titanic<br />3) Perl &gt;=5.8<br />  +) installed everywhere<br />  +) I'm good/fast at it, prototype in a couple weeks<br />  +) many git utilities are written in perl, good match<br />  -) declining popularity, fractured community<br />  -) modern libs require too much baggage (e.g. Moose)<br />  -) XS is the devil, no usable libgit2 bindings<br />4) Python<br />  +) installed everywhere I care about<br />  +) thriving community<br />  +) I have some experience (though still much slower than perl)<br />  +) libgit2 bindings exist<br />  +) some of the git tools are already python<br />  -) difficult to bundle with zero dependencies outside the git branch<br />  -) v2.5 -&gt; v3.x transition is in progress, which to choose? (prob 2.7)<br />5) Java<br />  +) just kidding!<br />6) Javascript/NodeJS<br />  -) I'm not kidding<br />  +) garbage collected, closures, functional style available, naturally async<br />  +) growing popularity, modules I'd need are fairly mature (relative to node.js)<br />  -) rapidly changing ecosystem/interfaces<br />
</pre><br />
  To be honest, I'm really leaning towards Go right now but it'd add a month or so before I have something
  useful.<br />
  <br />
  Comments, suggestions? Don't hold back, you know I wouldn't ;)
</div>
